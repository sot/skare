#!/usr/bin/env /proj/axaf/bin/perl

# this may be run either directly as a script or use'd as a module

use strict;
use warnings;

package SysPathSubst;

use autouse Cwd => qw( realpath );
use autouse 'File::Spec::Functions' => qw(catdir);

my $VERSION = '2.1.20';

my $prog;


run() unless caller();

use vars qw( @ISA @EXPORT_OK );

require Exporter;
@ISA = qw( Exporter );
@EXPORT_OK = qw( syspathsubst compact_paths );

sub prog
{
    require File::Basename;
    $prog ||= File::Basename::basename( $0 );
}

sub run
{
    my $ok = eval { main() };

    if ( $@ )
    {
	my $error = $@;

	my $prog = prog();
	print STDERR "$prog: $_\n" foreach split /\n/, $error;
	exit 1;
    }

    exit ! $ok;
}


sub main
{
    my %opt = opts();

    help(0)   if $opt{help};
    help(2)   if $opt{usage};
    version() if $opt{version};


    my $paths = syspathsubst( $opt{delimiter},
			      $opt{components},
			      @{$opt{templates}} );

    print $paths, "\n" if $paths;
}

sub syspathsubst
{
    my ( $delimiter, $components, @templates ) = @_;

    return compact_paths( $delimiter,
			  map { pathsubst( $components, $_ ) } @templates
			);
}

sub compact_paths
{
    my $delimiter = shift;

    my %in;

    my @paths = 
      grep { $_ && ! $in{$_}++ } 
      map { 'ARRAY' eq ref($_) ? catdir( @$_ ) : $_ } @_;

    return wantarray() ? @paths : join( $delimiter, @paths );
}


sub pathsubst
{
    my ( $components, $tpl ) = @_;

    $tpl = catdir( @$tpl )
      if 'ARRAY' eq ref $tpl;

    my $resolvelinks = $tpl =~ /%[lL]/;
    my $firstvalid   = $tpl =~ /%[LP]/;
    $tpl =~ s/%[pl]/%s/i;

    my @paths;

    # do minimum if nothing to fill
    if ( $tpl !~ /%s/ )
    {
	push @paths, $tpl
	  if -e $tpl
    }

    # templates to fill
    else
    {
	for my $cmp ( @$components )
	{
	    (my $tpath = $tpl) =~ s/%s/$cmp/;

	    $tpath = realpath( $tpath ) || $tpath
	      if $resolvelinks;

	    next unless -e $tpath;
	    push @paths, $tpath;
	    last if $firstvalid;
	}
    }
    return @paths;
}


sub opts
{
    require Getopt::Long;
    my %opt = ( delimiter => ' ' );

    eval {
        local $SIG{ __WARN__ } = sub { die $_[0] };

	Getopt::Long::GetOptions ( \%opt,
		     qw/
			components=s
			delimiter=s
			help
			usage
			version
			/,
		   );
    };

    die $@ if $@;

    return %opt if grep { $opt{$_} } qw/ help usage version /;

    die "missing path templates\n" unless @ARGV;

    $opt{templates} = [ map { split(':', $_ ) } @ARGV ];

    if ( ! defined $opt{components} )
    {
	chomp ($opt{components} = qx( /proj/axaf/simul/bin/sysarch platforms ));
	die 'error running sysarch' if $?;
    }

    $opt{components} = [ split(':', $opt{components} ) ];

    $opt{delimiter} = "\n" if $opt{delimiter} eq '\n';

    return %opt;
}


sub version
{
    print prog(), " ", $VERSION, "\n";
    exit 0;
}

sub help
{
  my ( $verbose ) = @_;

  require Pod::Usage;
  Pod::Usage::pod2usage ( { -exitval => 0, -verbose => $verbose } );
}

1;

__END__

=pod

=head1 NAME

syspathsubst - resolve system specific paths

=head1 SYNOPSIS

B<syspathsubst> [-c I<components>] I<pathlist> [I<pathlist>]

B<syspathsubst> -h | -u | -v

=head1 DESCRIPTION

B<syspathsubst> substitutes components into each element in a list of
path templates.  Typically it is used on networks with
multiple operating system and hardware combinations where execution
and library paths differ only by a system specific path component.
Using this package allows one to more easily specify those paths.

The final list of valid (existent) paths with duplicates removed is
output to the standard output stream.

The components to substitute are supplied by default by B<sysarch>
(invoked as C<sysarch -n platforms>) but may be explicitly provided via
the B<-p> option. They are substituted into path templates in the
order in which they are provided. In typical use (and if generated by
B<sysarch>) the components are ordered from most specific to most
generic.

The set of paths thus created is then filtered for duplicates and then
output as a delimited list.  Duplicates are determined based on
comparisons of the path names, not the fully resolved paths, so that
if two paths resolve to the same disk location but one uses symbolic
links, they will appear distinct.  To avoid this, use a path template
token which ensures that links are resolved.

=head1 OPTIONS AND ARGUMENTS

B<syspathsubst> takes as arguments one or more colon delimited lists of
path templates.

=over

=item B<-c> I<list>

Specify a colon delimited list of components to substitute into the
path templates

=item B<-d>, B<--delimiter>=I<DELIM>

Use I<DELIM> between output paths. Defaults to a space character.

=item B<-h>

Output short usage information and exit.

=item B<-u>

Output full usage information and exit.

=item B<-v>

Output the version and exit.

=back

=head1 PATH TEMPLATES


A path template is a string which can contain zero or one of a set of
special tokens.  The tokens indicate where in a path the system
specific component will be substituted, as well as the value of two
attributes, B<resolvelinks> and B<firstvalid>:

  Token   resolvelinks  firstvalid
  -----   -----------  ----------
   %s        false       false
   %p        false       false
   %P        false       true
   %l        true        false
   %L        true        true

If B<resolvelinks> is true, then after substitution any symbolic links
in the path are fully resolved.  This always results in an absolute
path.

If B<firstvalid> is true, then only the first existing path resulting
from the in order substitution of the system specific components is
retained.

For example, if the list of system specific components is

  c d e f

and the existent paths are

  /a/c /a/e /a/f

Then the path template C</a/%p> would result in a list of paths

  /a/c:/a/e:/a/f

while the path template C</a/%P> would result in

  /a/c

=head1 COPYRIGHT AND LICENSE

Copyright 2007 The Smithsonian Astrophysical Observatory

This software is released under the GNU General Public License.  You
may find a copy at: L<http://www.fsf.org/copyleft/gpl.html>

=head1 VERSION

This documents version 2.1.18.

=head1 Author

Diab Jerius E<lt>djerius@cfa.harvard.eduE<gt>
